/* 
# 48:实数加法

总时间限制: 1000ms 内存限制: 65536kB

## 描述

求两个实数相加的和。

题目中输入输出里出现的浮点数都有如下的形式：
$P_1P_2...P_i.Q_1Q_2...Q_j$。对于整数部分，$P_1P_2...P_i$是一个非负整数且当整数部分不为0时，$P_1$不等于0；对于小数部分，$Q_j$不等于0。

## 输入

2行，每行是一个加数。每个加数的长度不超过100。

## 输出

一行，即相应的和。输出保证一定是一个小数部分不为0的实数。

## 样例输入
```
0.111111111111111111111111111111
0.111111111111111111111111111111
```

## 样例输出
```
0.222222222222222222222222222222
```
 */
#include <stdio.h>
#include <string.h>
int main(void) {
	char a[2][101], *Int[2], *Frac[2], In, Fn, i, l[2], c=0;
#define _2 i=0;while(i<2)
	_2{//获取并拆分数字
		scanf("%s", a[i]);
		Int[i]=strtok(a[i], "."); 
		Frac[i++]=strtok(NULL, ".");
	}
//分数相加到较大数组中
	_2 l[i++]=strlen(Frac[i]);
	Fn=l[0]>l[1]?1:0;
	i=l[Fn]-1; while(i>=0){
		c=Frac[0][i]-'0'+Frac[1][i]-'0'+c;
		Frac[!Fn][i--]=c%10+'0';
		c/=10;
	}
//分数截断末尾0
	i=l[!Fn]-1; while(Frac[!Fn][i]=='0')i--;
	Frac[!Fn][++i]=0; 
//整数相加到较大数组中
	_2 l[i++]=strlen(Int[i])-1;
	In=l[0]>l[1]?1:0;
	while(l[In]>=0){
		c=Int[In][l[In]--]-'0'+Int[!In][l[!In]]-'0'+c;
		Int[!In][l[!In]--]=c%10+'0';
		c/=10;
	}
//剩余整数进位
	while(c&&l[!In]>=0){
		c=Int[!In][l[!In]]-'0'+c;
		Int[!In][l[!In]--]=c%10+'0';
		c/=10;
	}
//输出
	if(c)putchar(c+'0');
	printf("%s.%s\n", Int[!In], Frac[!Fn]);
}